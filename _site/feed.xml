<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2020-02-06T13:37:28+09:00</updated><id>/feed.xml</id><title type="html">……!</title><subtitle>derp derp derp</subtitle><author><name>Sangheon Lee</name></author><entry><title type="html">2020년 1월 말/2월 초 Problem Solving</title><link href="/algo/recent-ps-2020-02-0x/" rel="alternate" type="text/html" title="2020년 1월 말/2월 초 Problem Solving" /><published>2020-02-04T17:30:00+09:00</published><updated>2020-02-04T17:30:00+09:00</updated><id>/algo/recent-ps-2020-02-0x</id><content type="html" xml:base="/algo/recent-ps-2020-02-0x/">&lt;p&gt;풀려는 문제를 연습대회로 만들어서 풀기로 마음먹었습니다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;원래 풀고자 하는 문제들을 목록으로 만들어서 이 문제들만 보려고 했는데, 각 문제들과
같은 대회에 있었던 문제들 중에서도 재밌어보이는 게 많아 그냥 멋대로 잡탕처럼 풀기로 했습니다.&lt;/p&gt;

&lt;p&gt;1월 말~2월 초에 검수자로 들어가 있는 대회가 2개나 있어서 그동안은 2문제밖에 못 풀었고, 개인적인 일도 겹쳐서 2월 4일이 되어서야 새로 문제를 풀기 시작했습니다.&lt;/p&gt;

&lt;h1 id=&quot;20200123&quot;&gt;2020.01.23&lt;/h1&gt;

&lt;h2 id=&quot;the-dragon-and-the-knights-cerc-2012-i번&quot;&gt;The Dragon and the knights (CERC 2012 I번)&lt;/h2&gt;

&lt;p&gt;직선을 잘 정렬한 다음, 점도 정렬해서 sweeping하듯이 각 $y$축 구간별로 점들이 몇 개 포함되는지 체크하고, 교점을 만나면 구간의 정보를 초기화시켜주는 방법을 짜보았으나 잘 진행되지 않았고 코딩도 많이 까다로웠습니다. 그런데 1KB 이내로 짠 사람들이 많아서 결국 풀이를 보고 감명받은 문제입니다.&lt;/p&gt;

&lt;p&gt;각 점이 있는 구역을 어떻게 표시할 수 있을까요? $N$개의 직선에 대해서 위아래 유무를 2진법으로 생각한 다음 $N$자리 2진수를 만들여 표시할 수 있습니다. 이러면 각 구역마다 유일한 2진수들을 가지게 됩니다. 그러므로 각 기사마다 이를 조사하여, 총 몇 개의 다른 구역에 기사들이 있는지 셀 수 있습니다. $O(NM)$에 조사하고, $O(M \lg M)$에 정렬하면 끝입니다.&lt;/p&gt;

&lt;p&gt;직선으로 나뉜 전체 구역의 개수는 굳이 오일러의 공식까지 가지 않아도, “1 + 직선 개수 + 교점 개수”가 됨을 알 수 있습니다. 그러므로 두 값을 비교하여 같으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PROTECTED&lt;/code&gt;, 다르면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VULNERABLE&lt;/code&gt;을 출력하면 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;삼각-분할-boi-2009-5번&quot;&gt;삼각 분할 (BOI 2009 5번)&lt;/h2&gt;

&lt;p&gt;옛날부터 알고 있는 문제였는데, 갑자기 풀이가 떠올라서 금방 풀 수 있었습니다.&lt;/p&gt;

&lt;p&gt;삼각 분할 관계 트리로 변환하여 생각할 수 있으므로, 결국 이 문제는 “트리의 각 노드를 특정한 색으로 칠할 때, 같은 색인 임의의 두 노드가 연결되어 있도록 할 때 최대한 제거할 수 있는 간선의 수를 구하는 문제”로 환원됩니다.&lt;/p&gt;

&lt;p&gt;달리 생각하면 같은 색인 임의의 두 노드를 연결하는 방식으로도 할 수 있으므로, rooted tree를 구성한 다음 색깔이 같은 두 노드를 disjoint-set을 통해서 LCA랑 잘 합치는 방법으로 해결할 수 있습니다. 즉 LCA랑 두 노드가 같은 집합이 되게 합치는 과정을 반복하면 됩니다. merge를 할 때는 root에 가까운 쪽을 root로 설정하는 게 편합니다. 병합은 최대 간선 개수만큼 일어나고, LCA를 찾는 것도 $O(\lg N)$에 가능하므로 시간 복잡도 상으로도 충분합니다.&lt;/p&gt;

&lt;p&gt;다른 분 풀이를 보니 단절점/단절선으로 접근할 수 있는 것 같은데, 깊게 생각해보진 않았습니다.&lt;/p&gt;

&lt;h1 id=&quot;20200124--0202&quot;&gt;2020.01.24 ~ 02.02&lt;/h1&gt;

&lt;p&gt;개인적인 일도 겹치고, 제1 전시관 검수도 당시 상황에서 최선을 다했습니다. 정말 어려웠지만 덕분에 많이 배웠습니다.&lt;/p&gt;

&lt;h1 id=&quot;20200204&quot;&gt;2020.02.04&lt;/h1&gt;

&lt;p&gt;연습셋의 기간도 갱신하고 새롭게 시작하였습니다.&lt;/p&gt;

&lt;h2 id=&quot;레스토랑-coci-20092010-contest-7-6번&quot;&gt;레스토랑 (COCI 2009/2010 Contest #7 6번)&lt;/h2&gt;

&lt;p&gt;그래프의 간선을 빨간색 또는 파란색으로 칠하는데, 연결된 간선이 2개 이상 있는 모든 정점에 대해 최소 빨간 간선 하나와 파란 간선 하나가 연결되어있도록 칠하는 방법을 구하는 문제입니다.&lt;/p&gt;

&lt;p&gt;빨간 간선과 파란 간선을 그래프 순회를 할 때 “들어왔다가 나가는 것”으로 해석해볼 수 있습니다. 들어올 때와 나갈 때의 색깔을 다르게 칠하면 되기 때문입니다. 때문에 트리나 길이가 짝수인 사이클은 교대로 색을 칠하면 가능함을 알 수 있고, 길이가 홀수인 사이클은 어떻게 해도 불가능함을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;그럼 조금 더 일반적인 그래프일 때는 어떨까요? 다음과 같이 접근해볼 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;우선, 간선 1개(degree가 1)와 연결된 모든 정점에 대해 오일러 투어를 합니다. 말이 오일러 투어지, 사용되지 않은 간선에 대해 DFS를 하겠다는 뜻입니다. 중간에 indegree가 1개뿐인 정점이 생성되면 queue에 넣어서 모두 처리해줍니다.
    &lt;ul&gt;
      &lt;li&gt;degree가 1인 정점을 미리 처리하는 이유는, 기본적으로 오일러 투어는 자기 자신으로 돌아오는 회로를 찾기 떄문입니다. 그러나 degree가 1이면 돌아올 수도 없고, 다른 정점의 오일러 투어를 방해할 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이후, degree가 3 이상인 모든 정점에 대해 오일러 투어를 합니다. 당연히 윗 과정에서 사용한 간선은 제외하고 세어야 합니다. leaf가 없기 때문에, 간선 3개 이상 연결된 모든 정점은 자기 자신으로 돌아오는 순회가 존재합니다. 때문에 첫 순회에서 나가는 간선을 빨간색으로 칠했고, 다시 이 정점에서 순회를 시작하게 되면 파란색으로 칠하면 됩니다. 순회 중간에 파란색을 통해 다시 간선으로 돌아오면 아무래도 상관 없습니다.&lt;/li&gt;
  &lt;li&gt;마지막으로 간선 2개와 연결된 모든 정점에 대해 오일러 투어를 합니다. (확실하진 않지만) 사이클만 남아 있을 것입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;때문에 이 문제에서는 오일러 투어를 할 때 parity을 넣어주어야 할 뿐만 아니라, 같은 정점에서도 다음 정점을 갈 때마다 자기 자신의 parity를 바꾸어주어야 합니다. 그래야 다른 색깔의 간선을 칠할 수 있기 때문입니다.&lt;/p&gt;

&lt;p&gt;이 과정을 거치며 적당히 각 정점에 무슨 색 간선들이 있는지 기록하고, 마지막에 확인하면 됩니다. 그래프 이론에 대한 관찰과, 오일러 투어에 parity를 넣는 접근이 동반되어야 해결할 수 있는 문제였습니다.&lt;/p&gt;

&lt;p&gt;처음 풀 때는 parity까진 접근했었지만 정점 내부에서 parity를 바꾸어주며 탐색해야 한다는 생각은 하지 못했었는데, 다행히 다음 반례를 발견하였습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;7 7
1 2
1 3
3 4
4 1
2 5
5 6
6 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이러면 degree가 1인 정점이 없기 때문에 degree가 3인 1번 정점부터 시작하게 되는데, 오일러 투어 함수에서 두 번째 탐색시 색을 바꾸지 않으면 (1,2), (1,3), (4,1)이 모두 같은 색을 가지게 됩니다.&lt;/p&gt;

&lt;h1 id=&quot;20200205&quot;&gt;2020.02.05&lt;/h1&gt;

&lt;h2 id=&quot;l퍼즐-nwerc-2011-d번&quot;&gt;L퍼즐 (NWERC 2011 D번)&lt;/h2&gt;

&lt;p&gt;인접한 B와 W가 연결되어 있냐를 boolean 변수로 저장한다고 할 때, B 기준 가로 / 세로별로 1개씩 연결되어야 있어야 하므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(A || B) &amp;amp;&amp;amp; (~A || ~B)&lt;/code&gt;가 성립해야 합니다. 여기까지는 생각했었는데, W는 모든 인접한 B에 1개 연결되어 있어야 한다는 점을 잘 모르겠어서 풀이를 봤는데, 왜 생각하지 못했을까 싶을 정도로 단순하게 풀렸습니다.&lt;/p&gt;

&lt;p&gt;W 옆에 있는 B와의 연결 유무 변수를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A, B, C, ...&lt;/code&gt;라고 하면, 서로 다른 변수들끼리 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~A || ~B&lt;/code&gt;를 해주면 됩니다. 이러면 두 개 이상 참이 되는 변수가 없음을 알 수 있습니다. 그 외의 다른(W 옆에 있는 W나 . 등등) 변수들은 거짓으로 설정 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~A || ~A&lt;/code&gt;)해주면 됩니다. 이러면 W 기준으로 1개 이상 연결되어야 한다는 건 B쪽에서, 1개 이하로 연결되어야 한다는 건 W쪽에서 처리가 되어 2-SAT을 돌리면 됩니다. 물론, B : W = 1 : 2인 건 확인해주어야 합니다.&lt;/p&gt;

&lt;p&gt;홀짝성을 이용해 2-SAT 없이도 풀 수 있는 것 같으나, 나중에 이해해보기로 했습니다.&lt;/p&gt;

&lt;h2 id=&quot;crocodiles-underground-city-ioi-2011-4번&quot;&gt;Crocodile’s Underground City (IOI 2011 4번)&lt;/h2&gt;

&lt;p&gt;1년 전에 풀고 실패했을 때는 난맞왜틀을 했었는데, 지금 보니 괜히 IOI에서 100명 이상 맞은 문제가 아닌가 싶습니다.&lt;/p&gt;

&lt;p&gt;탈출구에서는 자명하게 바로 탈출할 수 있습니다. 나머지는 최소 2개의 ‘탈출할 수 있는 정점’과 인접해야 합니다. 안 그러면 탈출할 수 있는 정점 쪽 통로를 막아버리면 되기 때문입니다. 때문에 탈출구를 전부 초깃값 (거리 0)으로 설정해서 다익스트라 알고리즘을 사용하되, 두 번째로 방문했을 때만 값을 취하면 됩니다. 첫 번째로 도달했을 때의 경로가 일반적으로 최적이지만, 문지기가 막아버릴 것이기 때문입니다. 그리고 문제 조건에 의해 두 번째로도 도달할 수 있음이 보장되며, 탈출구가 아닌 다른 정점은 이런 식으로 거리를 계산해야 함이 보여집니다.&lt;/p&gt;

&lt;p&gt;코드도 간결합니다. 역시 IOI 문제입니다.&lt;/p&gt;</content><author><name>Sangheon Lee</name></author><category term="PS" /><summary type="html">풀려는 문제를 연습대회로 만들어서 풀기로 마음먹었습니다.</summary></entry><entry><title type="html">2019 ICPC Asia Da Nang Regional Contest 후기</title><link href="/algo/pdz-2019-danang-regional/" rel="alternate" type="text/html" title="2019 ICPC Asia Da Nang Regional Contest 후기" /><published>2020-01-27T23:00:00+09:00</published><updated>2020-01-27T23:00:00+09:00</updated><id>/algo/pdz-2019-danang-regional</id><content type="html" xml:base="/algo/pdz-2019-danang-regional/">&lt;p&gt;Powered by Zigui (pbz) 팀의 2019 ICPC Asia Da Nang Regional Contest 후기입니다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;돌아오는 비행기를 기다리며 작성한 내용이 많았는데, 그 이후 잊고 살다가 이제야 마무리해봅니다.&lt;/p&gt;

&lt;h1 id=&quot;20191204-d-2&quot;&gt;2019.12.04 (D-2)&lt;/h1&gt;

&lt;p&gt;1 WA = 5 Push Up 팀과 BFS_BROUGHT_ME_HERE 팀과 동행했습니다. 모두 멋있는 분들입니다.&lt;/p&gt;

&lt;p&gt;비행기를 탔습니다. 밤 9시 15분 출발 비행기가 10시나 되서야 이륙했고, 현지 시간 밤 1시에 도착했습니다. 지난주부터 난 감기 몸살 때문인지 5시간 비행시간 내내 자려고 하면 콜록콜록하며 깼습니다. 옆의 팀원은 안쓰러워했고 앞의 모르던 한국인 아주머니께서 불쌍했는지 땅콩캐러맬도 주셨지만 효과는 별로 없었습니다…ㅠㅠ&lt;/p&gt;

&lt;p&gt;베트남 다낭 공항에 내려서, 여차저차 예약해둔 유심칩을 찾고, Grab를 통해 택시를 잡아 호텔로 향했습니다. 체크인하니 밤 2시. 배정받는 방은 조금 컴팩트한 디럭스 트윈이었는데, 알고보니 제가 있던 방만 그랬던 거라서 더 슬펐습니다. 아무튼 정신 없이 하루가 정리되어 잤습니다.&lt;/p&gt;

&lt;h1 id=&quot;20191205-d-1&quot;&gt;2019.12.05 (D-1)&lt;/h1&gt;

&lt;p&gt;9시 조금 전에 일어나 조식을 먹고 좀 쉬다가 팀 등록을 11시 정도에 했습니다. 베트남 리저널 전통의 인터뷰와 사진 촬영이 있었고, ICPC 티셔츠를 받았습니다. 작년에는 빨간색이었는데 올해는 노란색이었습니다.&lt;/p&gt;

&lt;p&gt;12월의 베트남은 생각보다 춥고 바람이 많이 불었습니다. I HATE MATH 후드티를 내내 입고 다니길 너무 잘했습니다. NUT로 이동한 다음 안무 공연을 듣고, 개회식이 있었습니다. 적당히 아호코라식 + 행렬곱 문제를 풀면서 들었습니다. 1시간 정도 설명을 한 다음 연습 세션으로 넘어갔습니다.&lt;/p&gt;

&lt;p&gt;작년 베트남 리저널과 여러모로 상황이 달랐습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;일자형 테이블이 일렬로 배열되어 있지 않고 4개가 정사각형 모양으로 모여 있었습니다.&lt;/li&gt;
  &lt;li&gt;키보드는 버튼이 조금 큰 감은 있었지만, 예상보다 매우 편했습니다.&lt;/li&gt;
  &lt;li&gt;반면 화장실 시설은 심각할 정도로 열악했습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;연습 세션은 시간이 계속 왔다갔다하다가 1시간 정도 진행되었는데, 이전 리저널에 나온 바 있는 하-중 정도의 그리디 / 구현 / 인터랙티브 문제로 구성되어 있었습니다. 키보드 테스트도 하고, 2주 전에 풀었던 그리디 문제였는데 말려서 스트레스 받고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push_back&lt;/code&gt;을 너무 많이 하면 시스템 자체가 2분 정도 뻑간다는 안 좋은 징조도 발견하였습니다. 제가 당시 컨디션이 안 좋아서 좀 날카로웠는데 때문에 연습 분위기는 그렇게 유쾌하진 않았습니다 ㅠㅠ 반면 Heno World! 팀이 5솔브나 한 건 정말 고무적이었습니다.&lt;/p&gt;

&lt;p&gt;연습이 끝나고는 식사를 하러 이동하였습니다. 바람이 많이 부는 식당이었는데, 같이 온 고려대 참가자들이 싫어하는 고수가 좀 많이 뿌려져 있었습니다…전 괜찮게 먹었는데 다른 참가자들에게는 좀 아니었던 모양입니다.&lt;/p&gt;

&lt;p&gt;이후 숙소에 8시 30분쯤 도착해서는 올해 Vietnam National 문제를 풀다 잤는데, Easy Probability는 KMP + 행렬곱으로 어찌어찌 AC를 받았는데 Final Exam의 피타고라스 쌍은 뭔 짓을 해도 TLE여서 슬펐습니다. 설상가상으로 팀원 SoulTch가 9시 35분부터 2시간동안 진행된 CF 604에서 말렸습니다. 멘탈 다잡으며 조금 늦게 잤습니다. 대회는 8시에 시작하고, 6시 30분에 나가야 하는데, 취침 시간은 거의 1시였고 처음에 누워서는 기침이 계속 나와서 잠도 못 잤습니다…ㅠㅠ&lt;/p&gt;

&lt;h1 id=&quot;20191206-d0&quot;&gt;2019.12.06 (D+0)&lt;/h1&gt;

&lt;p&gt;결전의 날이 밝았습니다. 아침 5시 30분에 기상하였는데 잠 잔 시간에 비해 기분이 상쾌했습니다. 어제 미리 korea market에서 가서 샀던 스벅 에스프레소 더블샷을 버스에서 마시며 갔으며, 대회장에 안착했습니다. 팀을 밖의 공터에 세우고 한 팀씩 호명해서 들어가는 방식이었는데, 어제도 오늘도 처음 10팀 안에 들었던 것 같습니다. 일찍 들어가서 화장실의 열악함(&lt;strong&gt;정말&lt;/strong&gt; 열악했습니다)도 확인하고, 짐 맡기는 곳도 따로 없다는 것을 확인하고 (팀별 봉투가 따로 없었습니다) 계속 팀원끼리 긴장 풀며 대회가 시작되기만을 기다렸습니다.&lt;/p&gt;

&lt;p&gt;문제지를 미리 뒤집어준 채로 나누어졌었는데, ‘Problem M’이라는 텍스트가 보여서 기겁했습니다. 그리고 근처에 네 번째에 위치한 풍선이 특히 많아보여서 D번을 먼저 풀자는 흥미로운 의견이 대두되었습니다. 서울 리저널과는 달리 큰 전광판을 통해 상위 스코어보드는 늘 볼 수 있었습니다.&lt;/p&gt;

&lt;p&gt;그렇게 20분 지연된 오전 8시 20분, 대회가 시작되었습니다.&lt;/p&gt;

&lt;p&gt;Kattis 쪽 문제는 &lt;a href=&quot;https://open.kattis.com/problem-sources/The%202019%20ICPC%20Asia%20Danang%20Regional%20Contest&quot;&gt;여기&lt;/a&gt;에서, 실 대회 사이트는
&lt;a href=&quot;https://danang19.kattis.com/&quot;&gt;여기&lt;/a&gt;에서 확인할 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;대회-경과&quot;&gt;대회 경과&lt;/h1&gt;
&lt;p&gt;로그인을 한 다음에 문제가 13개임을 확인하고, SoulTch가 디버그 코드부터 작성하였습니다.&lt;/p&gt;

&lt;h2 id=&quot;m-moscow-dream-008&quot;&gt;M. Moscow Dream (0:08)&lt;/h2&gt;
&lt;p&gt;M이 무려 2분에 퍼솔이 나와서 (…) SoulTch가 짜서 맞았습니다.&lt;/p&gt;

&lt;h2 id=&quot;d-dating-time-024-1&quot;&gt;D. Dating time (0:24, +1)&lt;/h2&gt;
&lt;p&gt;두 시각 사이에 시침과 분침이 이루는 각도가 0 / 90 / 180일 때의 횟수를 구하는 건데, 일단 풀겠다고 잡았으나 약간 혼란스러운 상태에서 cos 값을 naive하게 비교하는 것으로 접근하였습니다. sin과 cos 용례를 헷갈려서 한 번 틀리는 실수를 하였는데, 예상 외로 이 문제를 1시간 넘어서 푼 상위권 팀들이 많았습니다. D라서 읽힌 속도가 느렸던 것으로 추정됩니다.&lt;/p&gt;

&lt;p&gt;지금 생각해보면 이 문제를 굳이 저렇게 풀어야 하나 싶지만, 뇌절이 왔음에도 불구하고 차분하게 넘긴 건 다행입니다.&lt;/p&gt;

&lt;h2 id=&quot;i-inspecting-illumination-030&quot;&gt;I. Inspecting Illumination (0:30)&lt;/h2&gt;
&lt;p&gt;Interactive 문제를 선호하는 SoulTch가 쉽다고 말하더니 정말 바로 풀었습니다.&lt;/p&gt;

&lt;p&gt;이후 스코어보드에는 큰 진전이 없었습니다. Patience from Yusuf가 A를 38분에 풀었지만 DP나 행렬로 접근이 어려워 일단 보류하였고, djkim0613은 G를, SoulTch는 L을, 저는 C를 생각하다가 H로 넘어갔습니다.&lt;/p&gt;

&lt;h2 id=&quot;l-latin-square-119&quot;&gt;L. Latin Square (1:19)&lt;/h2&gt;
&lt;p&gt;latin square 형태는 초기 상태가 valid하면 모든 칸을 valid하게 채울 수 있다는 성질을 예전에 배웠던 것 같은데 전 잘 기억이 안났습니다. 아무튼 SoulTch가 자신감을 가지고 network flow를 짜달라고 했고, 팀노트에서 복붙한 후 짜더니 맞았습니다. 나중에야 알았지만, 홀의 결혼 정리를 통해 존재성을 보일 수 있다고 합니다.&lt;/p&gt;

&lt;h2 id=&quot;h-hanjie-139&quot;&gt;H. Hanjie (1:39)&lt;/h2&gt;
&lt;p&gt;그 동안 H를 생각하고 있었는데, 잘 생각해보니 한 row 별로 나올 수 있는 가짓수가 길이 6일 때 (1, 1)의 10가지였고, $r, c &amp;lt;= 6$이므로 $10^6$에 valid check는 $36 \times 10^6$에 금방 할 수 있었습니다. 크게 막히지 않고 금방 짰으며 맞았습니다.&lt;/p&gt;

&lt;p&gt;이후 슬랙에서 ‘원기옥 모으고 있다’라는 말이 나올 정도로 한동안 AC가 없었습니다. djkim0613은 G를, SoulTch는 K를, 저는 F를 잡고 있었습니다. G가 WA가 중간에 몇 번 나왔었고, F도 짜보았으나 WA가 나와서 곰곰히 생각해보던 시간이었습니다. 이 때 G나 K나 문제를 잘 몰랐고 다른 팀원도 F를 잘 몰랐는데, 지금은 개인 플레이를 하며 문제를 밀어버리는 게 좋을 선택이었다고 생각합니다.&lt;/p&gt;

&lt;h2 id=&quot;g-generating-numbers-245-3&quot;&gt;G. Generating Numbers (2:45, +3)&lt;/h2&gt;
&lt;p&gt;슬랙에서 ‘한 번에 맞기 어려운 문제’로 평가되었던 G였습니다. 예외 처리 하나를 추가한 끝에 djkim0613이 AC시켰습니다. 잠깐 화장실 가려다가 돌아와서 뭐 하나 고친 다음에 내니 맞아서 신기했습니다. 이후 djkim0613은 C에 돌입.&lt;/p&gt;

&lt;h2 id=&quot;a-abstract-painting-301&quot;&gt;A. Abstract Painting (3:01)&lt;/h2&gt;
&lt;p&gt;슬랙에서는 이미 함정 문제라고 논의되고 있었는데, 대회장에서 이를 눈치챈 팀은 많지 않았습니다. A는 제가 생각했다가는 말릴 것 같아 더 생각 안 하고 있었는데, 갑자기 djkim0613이 수식 하나로 나오는 것 같다, 5분만에 짜봐서 내보는 건 어떨까라고 말했습니다. 반신반의의 심정으로 그러라고 했습니다. 이 때 SoulTch가 화장실에 있었는데, 셋이 있었다면 이 말을 듣고 어떤 판단을 내렸을지 궁금합니다.&lt;/p&gt;

&lt;p&gt;짜서 예제가 나오는 걸 확인하고 내니까 예상보다 오랫동안 채점이 되어서 정말 맞는 거 아냐? 싶었는데 정말 AC가 떠서 서로 박수치고 난리가 났었습니다.&lt;/p&gt;

&lt;p&gt;이후 출제진이 &lt;a href=&quot;https://codeforces.com/blog/entry/72047?#comment-565669&quot;&gt;의도적으로 제한을 작게 줬다고 밝혔습니다&lt;/a&gt;. 인상적인 멘트입니다.&lt;/p&gt;

&lt;h2 id=&quot;f-fair-bandwidth-sharing-322-1&quot;&gt;F. Fair Bandwidth Sharing (3:22, +1)&lt;/h2&gt;
&lt;p&gt;F 첫 제출은 F 퍼솔(2:28)이 나오기 전에 이루어졌었는데, 먼저 최소치만큼 할당하고 이차함수를 관리하는 걸 일차함수의 적분꼴로 바꾸어서, y에 대해 이분탐색을 하는 알고리즘이 틀린 것 같지는 않았습니다. y 제한을 이론치까지 늘리고 발견한 거였는데, 직선의 기울기가 상당히 작을 수 있어서 이분 탐색 횟수가 60번으로는 충분하지 않을 거라는 걸 깨달았습니다. 100번으로 늘리고 제출해보았습니다. 계속 Running일 때 얼마나 심장이 쿵쾅거렸는지 모릅니다. 결국 AC가 떴고, 2등으로 올라서게 됩니다.&lt;/p&gt;

&lt;p&gt;프리즈 당시 2등이었지만 A번을 안 푼 팀들이 상당히 많아서 언제 치고 올라올지도 모르는 상황이었고, 아직 K가 남아있어서 불안했습니다. 게다가 코드의 오류로 인해 push_back이 무한히 일어나 컴퓨터가 2분 정도 맛탱이가 가는 게 2번, stack overflow로 맛탱이가 간게 1번 있었습니다. 셋이 이 문제는 잡고 가야한다는데 동의하여 SoulTch는 컴퓨터를 잡고, 나머지 둘은 코드 로직은 잘 몰라도 대칭성이 어그러진 곳이 있는지 계속 확인하며 디버깅을 하였습니다. C를 손절하고 제가 B를 읽은 다음 쉬운 문제라는 걸 간파한 것도 이 때 즈음이었습니다.&lt;/p&gt;

&lt;h2 id=&quot;k-keep-it-sorted-433&quot;&gt;K. Keep It Sorted (4:33)&lt;/h2&gt;
&lt;p&gt;결국 K를 제출했고, 한 번에 맞아서 모두가 환호했습니다. 매우 복잡한 상태전이를 통해 해결하였는데, 푸시업 팀에게 들으니 9! 완전탐색을 돌리면 제한 안에 구할 수 있다고 해서 벙쪘습니다. 어쨌든 AC가 났을 때 나머지 둘은 축제 분위기였고 전 바로 B 코딩에 돌입했습니다.&lt;/p&gt;

&lt;p&gt;B가 처음에는 엄청 어려운 문제인 줄 알았는데, 알고 보니 각 바나나를 지나가는 원숭이는 단 한 마리고, 단 한 번 지나갈 수 있었습니다. 그냥 h좌표 스위핑하면 되는 문제여서 불꽃코딩에 들어갔습니다. 대회 종료 1분 30초 전에 예제가 나왔고, 냈으나 WA를 받고 여기까지인가 생각했습니다.&lt;/p&gt;

&lt;h2 id=&quot;대회-종료&quot;&gt;대회 종료&lt;/h2&gt;
&lt;p&gt;대회가 종료되었고 팀은 축제 분위기였습니다. BOJ 슬랙도 풍악을 올리고 있었습니다. 다른 팀의 패널티를 계산해도 인도네시아 팀 Patience from Yusuf를 제외하고는 역전할 팀이 없었습니다. 같이 고생한 1 WA = 5 Push Up과 BFS_BROUGHT_ME_HERE 팀도 와서 축하해주었습니다.&lt;/p&gt;

&lt;h1 id=&quot;대회-이후&quot;&gt;대회 이후&lt;/h1&gt;

&lt;p&gt;대회 이후 원래 호이안을 가려고 했던 것 같은데, 일정이 변경되어 사원을 방문하였습니다. 경건하게 사진도 찍고 적당히 잘 걸었습니다. 금방 숙소로 되돌아왔는데, 저와 SoulTch는 토요일 새벽 비행기를 타고 가기로 해 짐을 뺀 상태여서 1 WA = 5 Push Up 쪽 숙소에 가서 BABA IS YOU를 보며 놀았습니다.&lt;/p&gt;

&lt;p&gt;6시에 다시 대학으로 이동하여 폐회식을 시작하고, 스코어보드 공개가 진행되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/team-comp/danang-scoreboard.jpg&quot; alt=&quot;2019 ICPC Asia Da Nang Regional Contest Scoreboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Patience from Yusuf 팀은 결국 9솔로 2등을, Powered by Zigui 팀은 3등을 하였습니다. Heno World 팀은 유일한 10솔 팀이었는데, 다시 봐도 정말 강력한 멤버들로 이루어져 있는 것 같습니다 (CF 최고 레이팅 2600+이 두 명이나 됩니다). Send Bobs to Alice와의 박빙승부가 예상되었는데 많이 말린 듯 합니다.&lt;/p&gt;

&lt;p&gt;결과적으로는 턱걸이로 월파 티켓을 따냈지만, 이 때만 해도 다낭의 리저널 점수가 최상일 것으로 예상되었기에 3순위인 지구이팀도 갈 수 있는 확률이 높다고 점쳐졌습니다. 기분은 정말 좋았지만, 그보다는 정말 얼떨떨했습니다. 지금도 제가 월파를 간다는 사실이 실감이 안 될 때가 많습니다.&lt;/p&gt;

&lt;p&gt;시상식은 정말 금방 끝났고, 만찬이 제공되었는데 다들 맛있는 스테이크를 먹고 싶다고 해서 일찍 빠져나왔습니다. 잠시 대기하고 있을 때 2등팀의 코치와 인사를 할 기회가 있었는데 유쾌한 분 같았습니다. 나와서는 그랩 택시 타서 지구이 팀 세 명이 이런저런 이야기를 하며 시내의 스테이크 집으로 이동했습니다. 맛있었습니다! 스테이크집에서도 한국어 메뉴판이 있을 정도로 다낭엔 한글을 심심치 않게 볼 수 있었습니다.&lt;/p&gt;

&lt;p&gt;식사를 마치고 SoulTch와 공항으로 이동했습니다. 다낭의 공항은 인천공항에 비해서는 규모가 상당히 작았는데, 한국인이 빼곡하게 항공편을 기다리고 있었습니다. 가뜩이나 타려는 항공편이 지연되어서 꽤 오랜 시간을 대기해야 했는데, 줄이 줄지 않은 것을 보며 경악했습니다. 이 막간을 이용해서 이 포스트의 대회 파트까지 작성했습니다.&lt;/p&gt;

&lt;p&gt;이후는 잘 기억이 안 나네요. 다행히 대회때와 이후엔 감기 기운이 많이 줄어서 체력은 괜찮았지만 정말 많이 피곤했습니다. 비행기도 어찌어찌 탔고 다행히 올 때는 잘 잤으며, 나와서는 한국의 매서운 날씨를 맞보았습니다. 다낭에 있을 때가 공교롭게도 이번 겨울의 가장 추운(영하 10도 정도) 기간 이었습니다. 짐 찾고 공항버스를 타고 집에 도착해서 뻗었습니다.&lt;/p&gt;

&lt;h1 id=&quot;여담&quot;&gt;여담&lt;/h1&gt;

&lt;p&gt;결과 덕분에 미화된 것도 있겠지만, 적당한 난이도에 괜찮은 문제들이 많았던 세트였습니다. 다만 어느 팀도 풀지 못 한 E나 J중 하나는 없는 게 좋지 않았을까 싶습니다.&lt;/p&gt;

&lt;p&gt;이후 월파까지 같이 가는 팀이다보니, 종종 만나서 놀고 팀연습도 하고 PS 이야기도 조금씩 하고 있습니다. 여전히 B는 조금 아쉽습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;한참 지난 1월 말에 B를 업솔브해보았는데, indexing error 때문에 틀린 거였고 다시 짜본 결과 바로 맞았습니다. 코딩도 30분이 안 걸렸습니다. 10분만 더 있었으면…ㅠㅠ&lt;/li&gt;
  &lt;li&gt;B의 난이도에 비해 퍼솔이나 맞은 팀 수가 매우 어려워보이는 것은 무려 4쪽에 걸친 지문 때문이 아닐까 싶습니다. 저런 문제도 읽어보기는 해야 할 것 같다는 교훈을 얻었습니다.&lt;/li&gt;
  &lt;li&gt;C는 대충 풀이를 봤는데, 왜 생각 못했을까 싶은 아이디어와 조금 힘들어보이는 구현을 더하면 풀 수 있을 것 같습니다. 베트남에 빈번히 출제되는 수학 계열 문제입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;끝으로 같이 선의의 경쟁을 해온 1 WA = 5 Push Up 팀원 @IohcEjnim, @BaaaaaaaaaaaaaaarkingDog, @mixnuts 모두 고생하셨습니다. 그리고 이런저런 연습 속에서도 서로를 믿고 격려해준 @SoulTch @SUDAL 모두 감사드립니다!&lt;/p&gt;</content><author><name>Sangheon Lee</name></author><category term="PS" /><category term="ICPC" /><summary type="html">Powered by Zigui (pbz) 팀의 2019 ICPC Asia Da Nang Regional Contest 후기입니다.</summary></entry><entry><title type="html">ICPC 2019 World Finals 팀연습</title><link href="/algo/ICPC-2019-World-Finals-practice/" rel="alternate" type="text/html" title="ICPC 2019 World Finals 팀연습" /><published>2020-01-26T23:00:00+09:00</published><updated>2020-01-26T23:00:00+09:00</updated><id>/algo/ICPC-2019-World-Finals-practice</id><content type="html" xml:base="/algo/ICPC-2019-World-Finals-practice/">&lt;p&gt;2020년의 첫 팀연습을 지난 21일에 19 WF로 돌아보았습니다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;블로그에 아직 제대로 글을 쓰지는 않았지만 제가 작년에 속해 있던 Powered by Zigui 팀이 &lt;a href=&quot;http://blog.sina.cn/dpool/blog/s/blog_b946da100102zvya.html&quot;&gt;ICPC 2020 World Finals에 진출하게 되었습니다&lt;/a&gt;. 이후 지구이님과 다른 분들께 조언을 많이 듣고, 앞으로 자주 하지 못할 3인 팀연습을 19 WF로 진행하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/team-comp/20200121-wf19.PNG&quot; alt=&quot;20200125-team-result&quot; /&gt;&lt;/p&gt;

&lt;p&gt;결과는 생각보다는 저조했습니다. 서로 오랜만에 팀연습을 해서 그런지 각자의 기량이 잘 나오지 않았던 느낌이 들었습니다. 겸손하게 개인 연습을 계속 진행해야겠습니다.&lt;/p&gt;

&lt;p&gt;vjudge는 이번이 두 번째 사용인데, 정말 좋은 플랫폼인 것 같습니다.&lt;/p&gt;

&lt;h1 id=&quot;팀연습-경과&quot;&gt;팀연습 경과&lt;/h1&gt;

&lt;h2 id=&quot;초반-소강기&quot;&gt;초반 소강기&lt;/h2&gt;

&lt;p&gt;이전에 팀연습을 할 때 월파셋은 건드리지 않았는데, 바로 풀리는 문제가 정말 안 보였습니다. 일반적으로 월파 퍼솔은 7분에서 15분 사이에 나오는 쪽인데 이번에는 14분인 대회였습니다. 그런 점을 감안하더라도 풀이가 잘 보이지 않았습니다. 각자 문제를 읽어보다가 제가 보고 있던 E가 퍼솔이 나오자 더 쉽게 생각해보려고 노력했는데 잘 되진 않았습니다. 다행히 SUDAL이 A를 맡아 코딩하겠다고 했는데 25분에 있던 첫 제출이 WA가 나온 이후 서로가 답답한 상황이 계속되었습니다.&lt;/p&gt;

&lt;h2 id=&quot;e-dead-end-detector-102&quot;&gt;E. Dead-End Detector (1:02)&lt;/h2&gt;

&lt;p&gt;쉽게 쉽게 접근한 결과 컴포넌트가 트리일 때와 아닐 때로 분리해서 풀었는데, 첫 번째 문제 치고는 구현량이 조금 있었습니다. 제출하고 혹여나 실수했을까봐 조마조마했는데 다행히 AC가 나왔습니다. 이 문제도 틀렸으면 팀 퍼포먼스가 정말 안 나왔을 것 같습니다.&lt;/p&gt;

&lt;p&gt;팀연습을 하면서 퍼솔이 1시간 이후에 나온 경우는 거의 없었는데…대회 끝나고 문제 요구사항을 설명하려니 다른 팀원은 이해가 잘 안 된다고 말했습니다. 제가 맡아야 하나 봅니다.&lt;/p&gt;

&lt;h2 id=&quot;a-azulejos-127-1&quot;&gt;A. Azulejos (1:27, +1)&lt;/h2&gt;

&lt;p&gt;전날 친구들이랑 아줄이라는 보드게임을 했었는데 이런 문제가 나와서 재밌는 우연의 일치라고 생각했습니다. 작년 월파 스코어보드 실시간으로 보면서 이 문제가 쉬운 편이라는 건 알고 있었지만 문제는 모르는 편이었습니다.&lt;/p&gt;

&lt;p&gt;풀이를 들어보니 적당한 그리디와 적당한 자료구조의 사용으로 해결되는 것 같습니다.&lt;/p&gt;

&lt;h2 id=&quot;d-circular-dna-141&quot;&gt;D. Circular DNA (1:41)&lt;/h2&gt;

&lt;p&gt;A를 다시 코딩하고 있었을 때 D에 대한 풀이가 구체화 완료되었고, 제가 금방 짜서 맞았습니다. 개인적으로는 이 셋에서 가장 쉬운 문제라고 생각됩니다. 각 index 별로 따로 생각한 다음 prefix sum을 조합하여 하면 되는, 종합적이지만 (월파 수준에서는) 간단한 문제였습니다.&lt;/p&gt;

&lt;h2 id=&quot;중반부-소강기&quot;&gt;중반부 소강기&lt;/h2&gt;

&lt;p&gt;이 때 스코어보드는 ADE가 많이 풀리고, H 13팀, G 5팀, B 2팀, J 1팀이었습니다. SoulTch는 H를 계속 잡고 있었는데 뭔가 될듯 말듯 안 되는 상황인 것 같았습니다. 다른 문제를 둘러보면서 이상한 문자열 문제인 G를 잡느냐, 아니면 기하 문제 B를 잡느냐였는데 제가 B를 잡자고 주장해 남은 SUDAL과 제가 B를 합심해서 접근했습니다.&lt;/p&gt;

&lt;p&gt;H 제출이 먼저 3:29에 되었는데 RTE, 이후 연달아 3:33에 B 제출 WA, 다시 H 고쳐서 3:34에 제출한 결과 TLE였습니다. 실제 WF 환경에서는 그렇지 않겠지만 vjudge에서는 맞은 테스트 케이스 수가 나와서 H가 알고리즘은 맞는데 느린 부분이 있다는 점을 알 수 있었습니다.&lt;/p&gt;

&lt;h2 id=&quot;b-beautiful-bridges-344-1&quot;&gt;B. Beautiful Bridges (3:44, +1)&lt;/h2&gt;

&lt;p&gt;진작에 $O(N^2)$으로 접근해야 하며, 이를 위해서는 각 $i$번째에서 $j$번째로 직접 다리를 잇는 것이 가능한지 빠르게 판정해야 했습니다. 여기까지의 골자를 기반으로 SUDAL이랑 arch를 반반 나누어 접근했습니다. 저는 조금 복잡하게 접근했는데 SUDAL이 쉬운 케이스를 푼 다음, 이를 대칭시켜 어려운 케이스도 동일하게 해결하자는 아이디어를 냈습니다.&lt;/p&gt;

&lt;p&gt;구현도 실수 오차 거의 없이 SUDAL이 잘 했고 아이디어도 맞는 것 같아 제출했는데 앞서 말했듯 WA. 다행히 반례를 금방 찾았습니다. 여기서 제가 코드를 약간 잘못 이해해서 5분 정도 이상하게 대화가 꼬였는데 다행히 서로 보완할 점을 하나씩 찾고 제출하니 맞았습니다. 정말 다행이었습니다…&lt;/p&gt;

&lt;h2 id=&quot;h-hobsons-trains-454-2&quot;&gt;H. Hobson’s Trains (4:54, +2)&lt;/h2&gt;

&lt;p&gt;결국 SoulTch가 H에서 병목이었던 코드를 효율적으로 만들어서 AC를 받았습니다. H가 빨리 밀렸으면 6솔에서 7솔까지도 노려볼 수 있었을 것 같은데 아쉽습니다.&lt;/p&gt;

&lt;p&gt;H와 병행해서 제가 G를 도전해보았는데 WA를 받았습니다.&lt;/p&gt;

&lt;h1 id=&quot;팀연습-이후-문제-논의&quot;&gt;팀연습 이후 문제 논의&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;C. Checks Fast Porto
아무도 보지 않은 문제입니다. 실제로도 0솔이었으니…&lt;/li&gt;
  &lt;li&gt;F. Directing Rainfall
역시 별로 논의되지 않았습니다. 어려워보입니다…&lt;/li&gt;
  &lt;li&gt;G. First of Her Name
대회 끝나고는 왜 틀렸지 싶었는데 자기 전에 깨달아서 업솔빙했습니다.
이름의 역순으로 Trie를 만든 다음, Aho-Corasick을 이용해서 매 노드에서의 state를 저장하여 DP를 한 다음, failure link를 따라 역추적해야 하는 문제입니다. 현재 노드에서 다음 문자가 주어졌을 때 이동하는 과정도 효율적으로 진행되어야 합니다 (이것 때문에 TLE를 받았었고, 때문에 팀노트 구현체를 약간 수정했습니다). failure link가 트리를 이룬다는 사실을 이용하여 위상정렬하듯이 DP를 구해야 하는데, failure link에는 포함되지만 terminal이 아닐 경우 DP값은 0으로 간주해야 합니다. 이 부분을 간과하여 대회 도중에는 WA를 받았었습니다.&lt;/li&gt;
  &lt;li&gt;I. Karel the Robot
이런 류의 파싱 문제 좋아하는 SoulTch가 할만해보인다고 했으나 업솔빙 과정에서 그렇지 않음이 드러났습니다.&lt;/li&gt;
  &lt;li&gt;J. Miniature Golf
문제는 잘 모르지만 나머지 둘이 대회 끝나고 서로 조금 더 이야기해본 결과 시간복잡도를 괜찮은 수준으로 내려놓았습니다. 이후 SUDAL이 업솔브.&lt;/li&gt;
  &lt;li&gt;K. Traffic Blights
어떻게 이런 문제를 생각하고 풀 수 있을까요? 꼭 해결하고 싶은 문제입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;결론&quot;&gt;결론&lt;/h1&gt;

&lt;p&gt;앞으로 팀연습할 기회가 많지 않을텐데, 각자 연습을 많이 해야겠다는 다짐을 했습니다. 그리고 간만에 한 팀연습은 정말 재밌었습니다. 월파까지 다섯 달 정도 남았는데, 실력을 보다 열심히 갈고 닦도록 하겠습니다.&lt;/p&gt;</content><author><name>Sangheon Lee</name></author><category term="PS" /><summary type="html">2020년의 첫 팀연습을 지난 21일에 19 WF로 돌아보았습니다.</summary></entry><entry><title type="html">USACO 2020 January Contest</title><link href="/algo/USACO-2020-January-Contest/" rel="alternate" type="text/html" title="USACO 2020 January Contest" /><published>2020-01-25T20:00:00+09:00</published><updated>2020-01-25T20:00:00+09:00</updated><id>/algo/USACO-2020-January-Contest</id><content type="html" xml:base="/algo/USACO-2020-January-Contest/">&lt;p&gt;USACO Platinum을 오랜만에 쳐보았습니다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;대회를 다른 거 하면서 겸사겸사 치룬 와중에 1번 문제는 금방 풀려서 좋았습니다. 그러나 다음 두 문제를 생각할 시간이 별로 없었을 뿐더러 훨씬 더 어려웠습니다. 2번은 깊게 생각 안 했고 3번은 깊게 생각했었는데 삽질만 했습니다…시간이 나면 여기에 모든 Division의 문제 풀이를 작성해보도록 하겠습니다.&lt;/p&gt;</content><author><name>Sangheon Lee</name></author><category term="PS" /><summary type="html">USACO Platinum을 오랜만에 쳐보았습니다.</summary></entry><entry><title type="html">2020년 1월 중순 Problem Solving</title><link href="/algo/recent-ps-2020-01-1x/" rel="alternate" type="text/html" title="2020년 1월 중순 Problem Solving" /><published>2020-01-24T01:20:00+09:00</published><updated>2020-01-24T01:20:00+09:00</updated><id>/algo/recent-ps-2020-01-1x</id><content type="html" xml:base="/algo/recent-ps-2020-01-1x/">&lt;p&gt;풀고 싶은 문제만 쌓여가고 있습니다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;다양한-문제-풀이&quot;&gt;다양한 문제 풀이&lt;/h1&gt;

&lt;h2 id=&quot;boj-8339-fibonacci-machine&quot;&gt;BOJ 8339 Fibonacci Machine&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/8339&quot;&gt;문제 링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;lazy propgation을 통한 세그먼트 트리로 풀 수 있습니다. 구간 $[a, b]$에 대해 현재 합을 $F_{i_a} + F_{i_{a+1}} + \cdots + F_{i_b}$로, 이전 합을 $F_{i_a - 1} + F_{i_{a+1} - 1} + \cdots + F_{i_b - 1}$로 정의합시다. 각 구간에 대해 $m$번 피보나치 카운터를 올려야 한다면
&lt;script type=&quot;math/tex&quot;&gt;F_{n+m} = F_{m-1}F_n + F_m F_{n+1}&lt;/script&gt;
을 이용하여 한 번에 다음 합과 다음 ‘이전 합’을 갱신해줄 수 있습니다. $F_n$에 이전 합을, $F_{n+1}$에 현재 합을 넣어주면 됩니다. 좋은 연습 문제라고 생각합니다.&lt;/p&gt;

&lt;h2 id=&quot;boj-4342-유클리드-게임&quot;&gt;BOJ 4342 유클리드 게임&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/4342&quot;&gt;문제 링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이러한 종류의 게임은 서로 최적으로 게임을 진행할 때, 이기는지 지는지의 유무가 각 두 자연수 마다 결정되어 있습니다.&lt;/p&gt;

&lt;p&gt;간단히 용어를 정의하면,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이기는 상태 : 현재 플레이어가 최적으로 게임을 진행할 경우 승리하는 상태입니다. 이 경우 이동할 수 있는 다음 상태 중 지는 상태가 하나 이상 있습니다.&lt;/li&gt;
  &lt;li&gt;지는 상태 : 현재 플레이어가 무슨 수를 쓰더라도 상대가 최적으로 행동하면 지는 상태입니다. 이동할 수 있는 모든 상태가 이기는 상태입니다. 즉, 상대가 이기는 상태로밖에 이동하지 못합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제 게임을 분석해보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$(ka, a)$ 꼴의 경우 현재 차례인 사람이 이깁니다.&lt;/li&gt;
  &lt;li&gt;현재 수의 배치가 $P$라고 하고, 작은 수가 바뀌는 다음 배치를 $X$라고 하겠습니다.
    &lt;ul&gt;
      &lt;li&gt;$P$에서 할 수 있는 게 $X$로 가는 것밖에 없다면, $P$의 상태는 $X$의 상태의 반대입니다. $X$가 이기는 상태이면 $P$는 지는 상태이며, 그 반대도 성립합니다.&lt;/li&gt;
      &lt;li&gt;달리 생각하면, 이 상황은 &lt;strong&gt;큰 수를 작은 수로 나눈 몫이 1인 경우&lt;/strong&gt;입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;$P$에서 $X$ 말고 갈 수 있는 다른 상태가 있으면 $P$는 이기는 상태입니다.
    &lt;ul&gt;
      &lt;li&gt;$X$로 갈 수밖에 없는 배치를 $Q$라 하겠습니다. $P$에서는 $Q$로도, $X$로도 갈 수 있는데, 둘의 상태가 서로 반대이므로 상대에게 항상 지는 상태로 이동하게 할 수 있습니다.&lt;/li&gt;
      &lt;li&gt;이 상황은 &lt;strong&gt;큰 수를 작은 수로 나눈 몫이 2 이상인 경우&lt;/strong&gt;입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;유클리드 호제법에 의해 항상 $(ka, a)$ 꼴에 도달하게 되므로, 위의 메커니즘을 적용하여 재귀적으로 문제를  $O(\lg \max(a, b))$ 시간에 해결할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;coders-high-2014-j-fertilizing&quot;&gt;Coder’s High 2014 J. Fertilizing&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/10223&quot;&gt;문제 링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;흥미로운 문제입니다. 약간 까다로울 수 있는 그리디 아이디어를 착안해야 합니다. 바로 “$i$번째 과정 이후, 최댓값과 최솟값의 차는 $i$ 이하”라는 사실입니다. 때문에 가장 작은 콩나물들은 $i+1$번째 과정 이후엔 가장 큰 콩나물들이 됩니다.&lt;/p&gt;

&lt;p&gt;여기까지 아이디어가 나오면, 펜윅 트리나 세그먼트 트리를 통해 순차적으로 $[1, c_1]$, $[c_1+1, c_1+c_2]$, $[c_1+c_2+1, c_1+c_2+c_3]$ 처럼 콩나물을 기르고 $k_i$번째 콩나물의 키를 구하며 더하면 됩니다. 매 과정이 끝난 후 가장 작은 콩나물의 위치를 이동시키며 진행하면 됩니다.&lt;/p&gt;

&lt;p&gt;lazy propagation으로 짜니 시간 초과가 나서, 펜윅 트리로 다시 짰습니다. 시간 제한 3초였는데 600ms 정도로 통과되었습니다.&lt;/p&gt;

&lt;h2 id=&quot;boj-1294-문자열-장식&quot;&gt;BOJ 1294 문자열 장식&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1294&quot;&gt;문제 링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;아이디어를 완벽히 생각해내지 못해 결국 풀이를 검색한 문제입니다. 생각해보니 아이디어가 매우 자연스러워 더 슬펐습니다.&lt;/p&gt;

&lt;p&gt;$N$개의 문자열이 있을 때, 사전순으로 가장 앞서는 문자열의 첫 글자를 출력한 후, 이 문자열의 첫 글자를 제거한 후 계속 반복하면 됩니다. 이러면 최장 문자열의 길이가 $L$일 때 $O(NL^2)$에 해결 가능합니다.&lt;/p&gt;

&lt;h2 id=&quot;hackerrank--morgan-and-a-string&quot;&gt;HackerRank : Morgan and a String&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.hackerrank.com/challenges/morgan-and-a-string/problem&quot;&gt;문제 링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이 문제는 위의 문제랑 본질적으로 동일하지만 $N = 2$인 대신 $L \leq 10^5$입니다.&lt;/p&gt;

&lt;p&gt;문자열의 앞부터 하나씩 떼어가므로, 접미사 배열을 통해 $O(NL \lg L)$에 해결 가능합니다. 입력으로 들어오는 문자열이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt;이면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AxBx&lt;/code&gt; 꼴로 문자열을 만든 다음 관리하면 됩니다. 사이에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;를 더하는 이유는 두 문자열을 독립적으로 관리하면서도 같이 비교할 수 있게 하기 위함이며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;를 추가하였으므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt;에도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;를 추가해야 각 문자열 끝까지 갔을 때 비교가 정상적으로 됩니다.&lt;/p&gt;</content><author><name>Sangheon Lee</name></author><category term="PS" /><summary type="html">풀고 싶은 문제만 쌓여가고 있습니다.</summary></entry><entry><title type="html">2020년 1월 12일 Problem Solving</title><link href="/algo/daily-ps-2020-0112/" rel="alternate" type="text/html" title="2020년 1월 12일 Problem Solving" /><published>2020-01-13T19:30:00+09:00</published><updated>2020-01-13T19:30:00+09:00</updated><id>/algo/daily-ps-2020-0112</id><content type="html" xml:base="/algo/daily-ps-2020-0112/">&lt;p&gt;문제를 조금 풀고 CF 613을 버추얼로 해보았습니다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;boj-1376-민식우선탐색&quot;&gt;BOJ 1376 민식우선탐색&lt;/h1&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/1376&quot;&gt;BOJ 1376&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;특이한 순서로 DFS를 돌아야 합니다. 한 정점에서 방문할 수 있는 정점의 개수가 홀수면 중앙값의 정점 번호로, 짝수면 최소 정점 번호로 순회해야 합니다. 정점은 최대 $10^5$개지만 간선이 최대 $10^6$개입니다.&lt;/p&gt;

&lt;p&gt;동적으로 변하는 자료의 중앙값을 구하는 대표적인 방법은 세그먼트 트리 / 펜윅 트리로 k번째 원소를 구하는 함수를 작성하거나, 우선순위 큐 / 이진 탐색 트리 2개를 관리하여 가운데를 잘 나누는 것입니다. 저는 후자로 접근하여 편하게 이진 탐색 트리 기반인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::set&lt;/code&gt;으로 짜보았는데 시간 초과가 났고, 로컬에서도 5초 정도로 꽤 오래 걸렸습니다. 중앙 쪽 삽입 및 삭제가 빈번히 되기 때문인 것 같습니다.&lt;/p&gt;

&lt;p&gt;각 정점마다 인접한 정점 번호를 담는 컨테이너가 2개 ($C_1$, $C_2$) 있다고 하고, $C_2$의 원소가 $C_1$의 원소보다 크다고 합시다. 원소에 직접적으로 접근할 때는 $C_1$의 최솟값, $C_2$의 최솟값, $C_1$의 최댓값 정도밖에 없습니다. 원소의 삭제 때문에 임의의 원소에 접근 가능하지 않으면 어려워보일 수 있지만, lazy하게 그때그때 원소를 제거해나갈 수 있다면 상관이 없습니다.&lt;/p&gt;

&lt;p&gt;때문에 front/back의 pop이 자유로운 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::list&lt;/code&gt;로 구현했습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::deque&lt;/code&gt;은 메모리를 &lt;strong&gt;상당히&lt;/strong&gt; 많이 잡아먹습니다. 이에 대한 자세한 설명은 제가 삼성 소프트웨어 멤버십에 쓴 &lt;a href=&quot;http://www.secmem.org/blog/2019/11/14/c++-container-memory-usage/&quot;&gt;이 포스트&lt;/a&gt;에 나와 있습니다. 간단히 설명하면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::deque&lt;/code&gt; 하나당 기본적으로 (거의) 512바이트 단위로 청크를 조직하고 재할당도 일어나기 때문에 메모리 측면에서 비효율적입니다.&lt;/p&gt;

&lt;p&gt;원소 삽입은 정렬을 미리 한 다음 반으로 나누어 넣었으며, 컨테이너의 크기와 ‘컨테이너에는 있지만 이미 사용된 정점의 개수’를 관리하였습니다. 원소가 총 홀수 개 있을 때 $C_2$의 맨 앞 원소가 중앙값이 되도록 조절하였습니다.&lt;/p&gt;

&lt;p&gt;이 부분만 조금 더 자세히 설명해보겠습니다. 우리가 원하는 원소의 분포는 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$(0, 1)$, $(1, 1)$, $(1, 2)$, $(2, 2)$, $\cdots$, $(\lfloor n/2 \rfloor, \lfloor (n+1)/2 \rfloor)$ 등등&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 원소들은 기본적으로 ‘유효한’ 원소여야 합니다. 때문에 각 컨테이너에 속하지만 유효하지 않은 원소의 개수를 $x_1$, $x_2$라 하면&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\lvert C_1 \rvert - x_1 \leq \lvert C_2 \rvert - x_2 &lt; \lvert C_1 \rvert - x_1 + 1 %]]&gt;&lt;/script&gt;

&lt;p&gt;이 성립해야 합니다. 때문에 while문을 체크하면서 원소들을 옮겨주면 됩니다. 이 과정에서 유효하지 않은 원소가 뽑히면 제거합니다. 재미있게도 원소를 컨테이너에서 제거하는 과정은 $\lvert C_i \rvert - x_i$ 값에 영향을 주지 않습니다. 둘 다 1 감소하기 때문입니다. 그렇기에 저는 양쪽의 $\lvert C_i \rvert - x_i$의 균형을 맞춘 후, 양 끝의 유효하지 않은 원소를 제거하였습니다. 어떤 원소가 유효하지 않은 상태인지는 배열 하나만 있으면 충분합니다.&lt;/p&gt;

&lt;p&gt;여기까지 하면 각 상태에서 어느 정점으로 가야 할지는 쉽게 계산할 수 있습니다. 원소 개수가 짝수면 $C_1$의, 홀수면 $C_2$의 첫 원소를 선택하면 됩니다.&lt;/p&gt;

&lt;p&gt;원소들이 한 번 들어오고 한 번 빠질 뿐더러, 다음 원소를 고르며 균형을 깨뜨리는 과정의 복원이 금방 될 수 있다고 판단하였기에 시간 복잡도는 정렬 $O(n \lg n)$에 $O(n+m)$이라고 생각합니다. 그런 것 치고는 상당히 퍼포먼스가 600ms 대로 느리긴 했습니다, cache hit가 잘 일어나지 않아서라고 생각합니다. 아니면 제 알고리즘이 비효율적일지도 모릅니다.&lt;/p&gt;

&lt;h1 id=&quot;codeforces-round-613-div-2-virtual&quot;&gt;Codeforces Round #613 (Div. 2) Virtual&lt;/h1&gt;

&lt;p&gt;정말 오랜만에 돌아보는 코포 라운드 virtual입니다. 셋은 무난하게 좋았습니다. 본 대회 때 스코어보드를 보기만 했는데 유달리 거의 모든 문제에서 정답률이 낮아서 불안불안했습니다.&lt;/p&gt;

&lt;h2 id=&quot;a--mezo-playing-zoma-001&quot;&gt;A : Mezo Playing Zoma (0:01)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;L&lt;/code&gt; 하나로 1만큼 감소할 수 있고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; 하나로 1만큼 증가할 수 있으니 답은 $n+1$입니다. Div2A 치고 깔끔하고 좋다고 생각합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1285/submission/68638644&quot;&gt;코드 링크&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;b--just-eat-it-010&quot;&gt;B : Just Eat It! (0:10)&lt;/h2&gt;

&lt;p&gt;말릴 뻔했습니다. 정해는 prefix나 suffix 중 합이 0 이상인 게 있으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NO&lt;/code&gt;, 아니면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YES&lt;/code&gt;입니다. 저는 약간 헷갈려서 prefix sum을 multiset에 넣고 맨 마지막에서만 예외처리를 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1285/submission/68639052&quot;&gt;코드 링크&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;c-fadi-and-lcm-020-1&quot;&gt;C. Fadi and LCM (0:20, +1)&lt;/h2&gt;

&lt;p&gt;문제를 잘못 이해하고 냈다가 예제랑 안 맞는 것도 제대로 확인 안하고 한 번 틀렸습니다. $k \geq 1$일 때 $LCM(a, b) \leq LCM(a, kb)$이므로 곱이 $X$가 되야 한다는 결론에 도달할 수 있고, 소수의 거듭제곱꼴을 고려하면 같은 소인수는 한 번에 몰아주어야 한다는 아이디어를 떠올릴 수 있습니다. 가장 작은 소인수 11개의 곱이 $2 \times 10^{11}$보다 살짝 크므로, 소인수분해를 한 다음에 완전탐색으로 최대를 최소하하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1285/submission/68639696&quot;&gt;코드 링크&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;d-dr-evil-underscores-028&quot;&gt;D. Dr. Evil Underscores (0:28)&lt;/h2&gt;

&lt;p&gt;XOR이 나와서 처음에는 겁을 먹었으나 최상위 비트부터 접근해보니 상당히 쉽게 풀렸습니다. 최상위 비트부터 지금 보고 있는 모든 수의 해당 비트가 같으면 $X$의 해당 비트를 똑같이 설정하고 다음 비트로 내려가면 됩니다. 두 비트가 모두 등장하면, 두 경우 모두 하위 비트로 내려간 다음에 최솟값을 택하면 됩니다. 어느 쪽이든 $2^k$는 더해야 합니다.&lt;/p&gt;

&lt;p&gt;모범 코드는 정렬을 이용했는데, 저는 Trie 위에서 트리 DP 하듯이 조사했습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1285/submission/68640107&quot;&gt;코드 링크&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;e-delete-a-segment-130&quot;&gt;E. Delete a Segment (1:30)&lt;/h2&gt;

&lt;p&gt;너무 말리지 않았나 싶습니다. disjoint set이 필요한지 아닌지도 불확실했고, segment tree로 나뉜 구간의 개수를 어떻게 구해야하지도 잘 구체화가 안 되었었습니다. 잘 생각해보니 1로만 이루어진 구간에 완전히 걸치는 횟수가 중요할 것 같아서 어떻게 잘 세긴 했습니다. 그러나 자기 자신이 1로만 이루어진 구간일 때 처리가 조금 골치가 아팠습니다. 해당 경우에 대한 반례도 간단히 나와서 조금 더 생각해본 다음에 양 구간의 끝만 확인하는 식으로 했는데, 한 번에 맞아서 정말 다행이었습니다. 2250점 문제 치고는 어렵다고 생각합니다.&lt;/p&gt;

&lt;p&gt;세그먼트 트리를 이용해 힘겹게 풀 수도 있지만, 간결한 라인 스위핑 풀이가 있어 소개합니다. 결국 우리가 구하고자 하는 값은 “기존 컴포넌트 수” + “$i$번째 구간을 제거할 때 증가하는 컴포넌트의 수”의 최댓값입니다.&lt;/p&gt;

&lt;p&gt;구간을 event로 보아 추가는 $(l_i, -i)$, 제거는 $(r_i, i)$로 해석하여 정렬을 해봅시다. 구간 $P$ 입장에서 세그먼트 $Q$를 제거해서 컴포넌트의 수가 증가하는 경우는 다음을 만족해야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$P$는 $Q$에 포함되어야 합니다.&lt;/li&gt;
  &lt;li&gt;$P$를 추가할 때, 현재 존재하는 구간은 $Q$뿐이어야 합니다.
    &lt;ul&gt;
      &lt;li&gt;다른 구간이 존재한다면 $P$를 제거해도 컴포넌트의 수는 그대로입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;$P$보다 앞에 있으면서 $Q$와 겹치는 구간 $R$이 존재해야 합니다.
    &lt;ul&gt;
      &lt;li&gt;$Q$는 $P$와 $R$의 연결을 제거하는 역할이기 때문입니다.&lt;/li&gt;
      &lt;li&gt;예를 들어 $[1, 4]$, $[2, 3]$은 앞의 두 조건을 만족하지만, $[1, 4]$를 제거한다고 하여 컴포넌트의 수가 증가하진 않습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 조건은 의외로 코딩하기가 간단합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::set&lt;/code&gt; 등에 id를 저장하며 현재 보고 있는 구간을 관리하면 됩니다. 때문에 이런 $(P, Q)$를 발견하면, $Q$쪽의 기여도를 하나 증가하는 식으로 구현하면 됩니다. 이 과정에서 초기 상태의 컴포넌트의 수도 셀 수 있습니다. 여기까지만 하면 기여도를 확인하면서 정답을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1285/submission/68643375&quot;&gt;대회 코드 링크&lt;/a&gt;
&lt;a href=&quot;https://codeforces.com/contest/1285/submission/68697439&quot;&gt;업솔빙 코드 링크&lt;/a&gt; 
(지금 보니 주석에 문법 실수가 있네요 ㅠㅠ)&lt;/p&gt;

&lt;h2 id=&quot;f-classical&quot;&gt;F. Classical?&lt;/h2&gt;

&lt;p&gt;문제는 한 줄에 설명할 수 있는 수준입니다. $1 \leq i &amp;lt; j \leq n \leq 10^5$ 이고 $1 \leq a_k \leq 10^5$일 때 $\max(LCM(a_i, a_j))$을 구하면 됩니다.&lt;/p&gt;

&lt;p&gt;스코어보드부터 무시무시한 수준이라 풀 수 없을 거라고 생각했고 버추얼 때는 금방 단념했습니다. 풀이를 보니 좀 새로웠습니다. 여기서는 &lt;a href=&quot;https://codeforces.com/blog/entry/72950?#comment-572483&quot;&gt;개량된 정해&lt;/a&gt;를 서술하고자 합니다.&lt;/p&gt;

&lt;p&gt;우선 입력으로 들어오는 수들의 모든 약수를 배열에 추가한 다음에, 여기에서 2개의 서로소인 수들을 잘 고르자는 것이 취지입니다. 어차피 $LCM(a, b) = \frac{ab}{\gcd(a, b)}$이기 때문입니다.&lt;/p&gt;

&lt;p&gt;곱을 최대화해야 하니 큰 수부터 보는 건 맞는 것 같은데, 여기서 신기한 방법을 씁니다. 내림차순으로 순서대로 스택에 넣는데, 새로 넣을 수 $x$와 서로소인 수가 없을 때까지 스택에서 수를 빼내고, 빼내면서 $x$와 빼는 수의 곱의 최댓값을 답과 비교하여 최대를 취합니다.&lt;/p&gt;

&lt;p&gt;이 과정이 맞는 이유는 (아주 엄밀하진 않지만) 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$x$와 서로소인 수 $y$가 스택에 있으면 현재 $y$ 입장에서는 $xy$가 곱의 최댓값입니다. 왜냐하면
    &lt;ul&gt;
      &lt;li&gt;$y$ 보다 스택에 뒤에 있는 수들과는 서로소가 아니며&lt;/li&gt;
      &lt;li&gt;스택에 들어오는 수는 내림차순이므로 감소하기 때문입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이 과정에서는 $x$와 서로소가 아닌 수 $y$와도 곱을 계산하여 갱신하지만, 그래도 됩니다. 마지막으로 빼는 수는 $x$와 서로소이면서 가장 크기 때문입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$x$와 서로소인 수가 스택에 있는지는 뫼비우스 함수 등을 써서 포함 배제를 사용하면 됩니다. $cnt_i$를 스택에 있는 수들 중 $i$의 배수의 개수라 하면, 넣고 뺄 때는 $d\,\vert\,x$인 모든 $d$에 대해 값을 바꾸면 되며, $x$와 서로소인 수(즉 최대공약수가 1인 수)의 개수는&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\sum_{d\,\vert\,x} \mu(d) \cdot cnt_d&lt;/script&gt;

&lt;p&gt;로 계산할 수 있습니다.&lt;/p&gt;

&lt;p&gt;뫼비우스 함수를 간단하게 계산할 수 있는 코드도 알아갈 수 있었습니다.
위에도 링크된 댓글의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mango_lassi&lt;/code&gt;님 코드에서 영향을 많이 받았습니다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// mu : Möbius, dv : divisor&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAXN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAXN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1285/submission/68701006&quot;&gt;코드 링크&lt;/a&gt;&lt;/p&gt;</content><author><name>Sangheon Lee</name></author><category term="PS" /><category term="Codeforces" /><summary type="html">문제를 조금 풀고 CF 613을 버추얼로 해보았습니다.</summary></entry><entry><title type="html">2020년 1월 초반 Problem Solving</title><link href="/algo/recent-ps-2020-01-0x/" rel="alternate" type="text/html" title="2020년 1월 초반 Problem Solving" /><published>2020-01-10T23:00:00+09:00</published><updated>2020-01-10T23:00:00+09:00</updated><id>/algo/recent-ps-2020-01-0x</id><content type="html" xml:base="/algo/recent-ps-2020-01-0x/">&lt;p&gt;연말연초라 문제 풀이를 많이 하지는 못했습니다. HLD 정도만 제대로 다시 짜보고, 수학 문제들 위주로 풀어보았습니다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;topc-2015-e-egg&quot;&gt;TOPC 2015 E. Egg&lt;/h1&gt;

&lt;p&gt;문제 링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/11012&quot;&gt;BOJ 11012&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;대표적인 persistent segment tree 사용 문제이고, 이전에 썼던 포스팅과 비교해가며 코딩해보았는데 좌표 압축 과정에서 황당한 실수를 며칠간 발견 못 해 고생했었습니다.&lt;/p&gt;

&lt;h1 id=&quot;boj-1040-정수&quot;&gt;BOJ 1040 정수&lt;/h1&gt;

&lt;p&gt;문제 링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/1040&quot;&gt;BOJ 1040&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;찾아보니 반복문을 통해 수를 적절히 올려가며 되는지 안 되는지 판단하는 효율적인 전체 탐색도 있었는데, 잘 모르겠어서 그냥 동적 계획법으로 해결하였습니다.&lt;/p&gt;

&lt;p&gt;10개의 수 중 $K$개의 수를 사용하므로, $\binom{10}{K}$의 모든 조합에 대해 동적 계획법을 적용할 것입니다.&lt;/p&gt;

&lt;p&gt;상태는 다음 4가지를 요소로 구성됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;0의 경우, 지금 0이 와도 되는지 유무 (leading zero 관련)&lt;/li&gt;
  &lt;li&gt;남은 자리수를 배치할 때, 입력으로 주어진 수 이상으로 배치해야하는지의 유무&lt;/li&gt;
  &lt;li&gt;현재 보고 있는 자릿수의 위치&lt;/li&gt;
  &lt;li&gt;$k$개의 수 사용 유무를 의미하는 비트들&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이렇게 구성하면, 상태 전이는 반복문을 이용해 다음 자리로 넘어가는 방식으로 구성할 수 있습니다. 말로 설명하기가 어렵네요. &lt;a href=&quot;http://boj.kr/5b9f3fa4e74e40ae9aef087666455c8c&quot;&gt;코드&lt;/a&gt;를 보시는 게 이해가 빠를 것 같습니다. 시간 복잡도는 $O(\binom{10}{k} 2^k k)$인데 상태 표현 때문에 이런 저런 상수가 좀 크게 붙습니다.&lt;/p&gt;

&lt;h1 id=&quot;boj-17429-국제-메시-기구&quot;&gt;BOJ 17429 국제 메시 기구&lt;/h1&gt;

&lt;p&gt;문제 링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/17429&quot;&gt;BOJ 17429&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;기본적으로 HLD + segtree라 크게 코멘트할 부분은 없는 문제입니다. 나중에 다른 포스팅으로 설명하도록 하겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;boj-1078-뒤집음&quot;&gt;BOJ 1078 뒤집음&lt;/h1&gt;

&lt;p&gt;문제 링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/1078&quot;&gt;BOJ 1078&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;어떤 수 $D$가 주어질 때, $x$에서 $x$를 뒤집은 수를 뺀 수가 $D$가 되는 최소의 양의 정수 $x$를 찾는 문제입니다.&lt;/p&gt;

&lt;p&gt;우선 $x$에서 $x$를 뒤집은 수를 뺀 수는 9의 배수임을 알 수 있습니다. 때문에 9의 배수가 아니면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-1&lt;/code&gt;을 출력하면 됩니다. 그리고 9의 배수이면서 10의 배수가 아닌 $x$에 대해 답이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D&lt;/code&gt;일 때, $10x$의 답은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1D1&lt;/code&gt;이 됨을 관찰할 수 있습니다. 가장 큰 자릿수의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;와 가장 작은 자릿수의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;을 제외하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D&lt;/code&gt;가 10배 된 자리에 위치했기 때문입니다. $100x$는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10D01&lt;/code&gt;, $1000x$는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;100D001&lt;/code&gt;…로 진행됨을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그 다음부터가 문제입니다. $D$가 $10^6$ 이상인 $x$들이 있기 때문입니다. 전수조사를 100만 단위로 조금 해본 결과, 맨 앞자리가 1일 때만 유효한 $D$들이 있었습니다. 이를 맨 앞의 1의 위치를 옮겨가면서 반복해보았고, $10^9$까지 유효한 $D$들이 있었습니다. $10^{10}$ 이상일 땐 나타나지 않았는데, 반전을 통해서 영향을 받는 자리수가 너무 커져서라고 생각했습니다. 결과적으로 500만개의 수만 살펴보면서 정답을 확인할 수 있었습니다.&lt;/p&gt;

&lt;h1 id=&quot;제3회-kriiicon-ㅍ번-피보나미얼&quot;&gt;제3회 kriiicon ㅍ번 피보나미얼&lt;/h1&gt;

&lt;p&gt;문제 링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/11397&quot;&gt;BOJ 11397&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;피사노 주기와 관련된 문제로, 별도로 포스팅을 하도록 하겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;gcj-2008-round-1a-c2-numbers&quot;&gt;GCJ 2008 Round 1A C2 Numbers&lt;/h1&gt;

&lt;p&gt;문제 링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/12925&quot;&gt;BOJ 12925&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;선형 점화식과 관련된 유명한 트릭을 사용해야 합니다. $X_n = \alpha^n + \beta^n$이라 정의할 때,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;X_{n+2} = (\alpha + \beta) X_{n+1} - \alpha\beta X_n&lt;/script&gt;

&lt;p&gt;이 성립합니다. 식을 전개하면 그대로 나옵니다.&lt;/p&gt;

&lt;p&gt;때문에 이차방정식의 근과 계수와의 관계처럼, $\alpha = 3 + \sqrt{5}$, $\beta = 3 - \sqrt{5}$로 잡아봅시다. 그러면&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;X_{n+2} = 6 X_{n+1} - 4 X_n&lt;/script&gt;

&lt;p&gt;의 식이 유도됩니다. 이 때, $n$이 양의 정수이면 $0 &amp;lt; \beta^n &amp;lt; 1$임을 알 수 있습니다. 그러므로 $X_n$의 마지막 3자리(즉$\mod 1000$)를 알 수 있으면, $\alpha^n$의 마지막 3자리를 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;위 점화식을 통해 $X_{n}$을 알아내는 대표적인 방법은 행렬곱이지만, 저는 $X_n$의 본래 정의에 입각하여&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;X_{2n} = X_n^2 - 2 \times (\alpha\beta)^n, ~~ X_{2n+1} = X_nX_{n+1} - (\alpha+\beta)(\alpha\beta)^n&lt;/script&gt;

&lt;p&gt;를 이끌어내어 재귀적으로 계산하였습니다. 이 과정에서 조사하게 되는 $X_i$의 개수는 $O(\lg n)$개 정도이므로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::map&lt;/code&gt; 같은 map 형태의 자료구조를 이용하여 memoization을 통해 계산할 수도 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;boj-11691-lcmi-j&quot;&gt;BOJ 11691 LCM(i, j)&lt;/h1&gt;

&lt;p&gt;문제 링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/11691&quot;&gt;BOJ 11691&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;$\sum_{i}^{n}\sum_{j,\ i &amp;lt; j}^{n} \text{lcm}(i, j)$을 구하는 문제입니다. 뫼비우스 반전 공식 등을 이용하여 조금 더 나은 시간 복잡도를 보이는 풀이도 있는 것 같으나 여기서는 약간 일반화된 풀이를 소개하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;$\text{lcm}(a, b) = ab / \gcd(a, b)$이므로, $\gcd$를 잘 처리할 수 있는 방법을 생각해보아야 합니다. 여기서 특수한 수열 $w_i$를 정의하도록 하겠습니다. 수열 ${w_i}$는 다음을 만족합니다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\sum_{d | k} w_d = \frac{1}{k}&lt;/script&gt;

&lt;p&gt;에라토스테네스의 체를 구하는 것처럼, $w_1$부터 $w_n$까지 $O(n \lg n \lg \lg n)$에 구할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그 다음 계산하고자 하는 값은 $\sum_{i}^{n}\sum_{j}^{n} \text{lcm}(i, j)$입니다. $i = j$일 때만 제외하고 2로 나누면 구하고자 하는 값이 나옴을 알 수 있습니다. 여기서 식을 조금 변형해보겠습니다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align*}
\sum_{i}^{n}\sum_{j}^{n} \text{lcm}(i, j) &amp;= \sum_{i}^{n}\sum_{j}^{n} \frac{ij}{\gcd(i, j)} \\
&amp;= \sum_{i}^{n}\sum_{j}^{n}\left( ij\sum_{d|\gcd(i, j)} w_d\right)\\
&amp;= \sum_{d}^n\sum_{d|i}^n\sum_{d|j}^n ij w_d\\
&amp;= \sum_{d}^n w_d \sum_{d|i}^n\sum_{d|j}^n ij\\
&amp;= \sum_{d}^n w_d (\sum_{d|i}^n)^2
\end{align*} %]]&gt;&lt;/script&gt;

&lt;p&gt;위와 같이 변형하면, 1부터 $n$까지 중 $d$의 배수들의 합을 통해 위 식을 계산할 수 있고, 거기에서 제곱합을 빼서 원래 구하고자 했던 값을 계산할 수 있습니다. 수가 연속되어 있으므로 합공식을 이용하여 총 $O(n)$에 간단히 전처리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;주어진 수가 연속된 자연수가 아니라 수열일 때도 비슷하게 해결할 수 있습니다. 해당 문제는 &lt;a href=&quot;https://atcoder.jp/contests/agc038/tasks/agc038_c&quot;&gt;AGC 038 C번 LCMs&lt;/a&gt;로 출제된 바 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;제3회-kriiicon-ㅆ번-씽크스몰&quot;&gt;제3회 kriiicon ㅆ번 씽크스몰&lt;/h1&gt;

&lt;p&gt;문제 링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/11385&quot;&gt;BOJ 11385&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이 문제가 나올 당시였던 2015년 중순이라면 몰라도 이제 FFT와 NTT는 well-known topic이 되어 버렸습니다. 차수가 최대 $10^6$이므로, PS에서 주로 쓰이는 Cooley-Tukey FFT algorithm을 사용하려면 최대 크기 $2^{21}$의 배열을 다루어야 합니다.&lt;/p&gt;

&lt;p&gt;일반적으로 FFT는 NTT보다 빠르지만, 이 문제는 FFT 실수 오차가 상당히 빡세다고 합니다. 그걸 모르고 NTT로 짜보았는데, 순환군의 크기가 $2^{21}$ 이상이면서 곱하면 $10^{18} + 10^{12}$를 근소하게 넘고, $2^{63}-1$보다 작으며, 각각의 크기는 $2^{31}-1$보다 작은 NTT-friendly 소수 2개가 다행히 팀노트에 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$998244353 = 119 \times 2^{23} + 1$. 원시근: $3$.&lt;/li&gt;
  &lt;li&gt;$1012924417 = 483 \times 2^{21} + 1$. 원시근: $5$.&lt;/li&gt;
  &lt;li&gt;이 둘의 곱은 $10^{18} + 10^{12}$보다 조금 더 큽니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그래서 이 값을 구하고, 중국인의 나머지 정리까지 갈 것도 없이 연립합동방정식을 세워 원래 값을 복원해낼 수 있습니다. 10초 제한에 9초나 걸렸습니다. NTT가 여러모로 느리다는 걸 다시 깨달았습니다.&lt;/p&gt;</content><author><name>Sangheon Lee</name></author><category term="PS" /><summary type="html">연말연초라 문제 풀이를 많이 하지는 못했습니다. HLD 정도만 제대로 다시 짜보고, 수학 문제들 위주로 풀어보았습니다.</summary></entry><entry><title type="html">Persistent Segment Tree w/ BOJ 13538</title><link href="/algo/persistent-segment-tree-xor-query/" rel="alternate" type="text/html" title="Persistent Segment Tree w/ BOJ 13538" /><published>2019-12-29T19:30:00+09:00</published><updated>2019-12-29T19:30:00+09:00</updated><id>/algo/persistent-segment-tree-xor-query</id><content type="html" xml:base="/algo/persistent-segment-tree-xor-query/">&lt;p&gt;헷갈리던 Persistent Segment Tree를 드디어 이해했습니다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Persistent Segment Tree란, 크기 $N$의 segment tree가 총 $M$번 상태 변화가 일어날 때, 이를 공간 복잡도 $O(N + M \lg N)$에 저장하는 자료구조입니다. 대표적인 예시로 2차원 격자에서, 점 갱신이 일어나지 않을 때 $x_1 \leq x \leq x_2$이면서 $y_1 \leq y \leq y_2$를 만족하는 점의 개수를 구하는데 사용될 수 있습니다.&lt;/p&gt;

&lt;p&gt;Persistent Segment Tree의 개념은 다른 블로그에 설명이 잘 되어 있으므로, 여기서는 &lt;a href=&quot;https://icpc.me/13538&quot;&gt;BOJ 13538 XOR 쿼리&lt;/a&gt;를 해결하는데 사용한 코드를 서술하고 풀이해보자 합니다. 이해가 될 듯 말 듯 한 분들은 코드의 설명을 보시는 게 나을 수도 있습니다.&lt;/p&gt;

&lt;p&gt;코드는 &lt;a href=&quot;https://cubelover.tistory.com/15&quot;&gt;cubelover님의 코드&lt;/a&gt;와 매우 흡사하게 진행됩니다.&lt;/p&gt;

&lt;h1 id=&quot;요구-사항&quot;&gt;요구 사항&lt;/h1&gt;

&lt;p&gt;이 문제의 골자는 다음과 같습니다. 배열 $A$가 있을 때,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1번 쿼리 : $A$의 끝에 $x$를 추가&lt;/li&gt;
  &lt;li&gt;2번 쿼리 : $A[L, R]$에서 $x$와 XOR한 값이 최대인 $y$ 계산&lt;/li&gt;
  &lt;li&gt;3번 쿼리 : $A$의 마지막 $k$ 개 원소 삭제&lt;/li&gt;
  &lt;li&gt;4번 쿼리 : $A[L, R]$에서 $x$ 이하의 원소 개수 계산&lt;/li&gt;
  &lt;li&gt;5번 쿼리 : $A[L, R]$에서 $k$ 번째로 작은 수 계산&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root[i]&lt;/code&gt;를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i&lt;/code&gt;번째 값까지 추가한 세그먼트 트리의 root라고 하면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root[i]&lt;/code&gt;의 값이 갱신되는 경우는 없음을 알 수 있습니다. 마지막 원소를 삭제하는 건 갱신이 아닌 삭제이고, 이전의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root[i]&lt;/code&gt;에는 영향을 미치지 않기 때문에 갱신이 아닙니다.&lt;/p&gt;

&lt;h1 id=&quot;pst-코드&quot;&gt;PST 코드&lt;/h1&gt;
&lt;p&gt;코드와 함께, 이 쿼리들을 어떻게 처리하는지 보도록 하겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;node-구조체&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node&lt;/code&gt; 구조체&lt;/h2&gt;

&lt;p&gt;Persistent Segment Tree의 각 노드는 이진 트리답게, 왼쪽 / 오른쪽 자식을 가리키는 포인터와 현재 값을 저장합니다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 이 노드를 얼마나 저장해야 하느냐도 중요합니다. 크기를 $N$, 변화 개수를 $M$이라 할 때&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1-indexed 초기 세그먼트 트리는 $2N$개의 노드를 요구로 합니다.&lt;/li&gt;
  &lt;li&gt;이후, 세그먼트 트리의 변화를 저장할 때마다 $\lg N$개의 칸이 갱신되고, 별도로 한 개의 root node가 할당됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러므로 node는 $2N + M (\lg N + 1)$개 있으면 되고, 각 세그먼트 트리의 root를 저장할 node pointer $M+1$개가 필요합니다. 코드에서는 혹시 몰라 1을 추가했습니다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;500000&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;500005&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;초기화&quot;&gt;초기화&lt;/h2&gt;

&lt;p&gt;PST의 기본이 되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root[0]&lt;/code&gt; 세그트리입니다. 모든 값을 0으로 세팅하고, 자식 관계만 설정해주되 리프 노드는 그대로 내버려둡니다. 이러면 의미상 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a[1]&lt;/code&gt;이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root[0]&lt;/code&gt;이 되며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a[0]&lt;/code&gt;은 null pointer를 의미하게 됩니다. 이는 1-index 세그먼트 트리랑 비슷합니다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tcnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;19&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tcnt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;세그먼트-트리-생성&quot;&gt;세그먼트 트리 생성&lt;/h2&gt;

&lt;p&gt;기존 세그먼트 트리들로부터 새로운 세그먼트 트리를 생성하는 과정입니다. 알고리즘을 생각하면 그리 어렵진 않습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;우선, 새로운 루트 노드를 할당합니다. (처음에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt;로 들어갑니다)&lt;/li&gt;
  &lt;li&gt;한 칸 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;)만 갱신이 되기 때문에, 직전의 세그먼트 트리를 의미하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;q&lt;/code&gt;에서 $O(\lg n)$개 정도의 노드 변화만 있게 됩니다.&lt;/li&gt;
  &lt;li&gt;바뀌는 쪽만 새로 노드를 할당하고, 그대로인 쪽은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;q&lt;/code&gt;의 자식을 그대로 대입합니다.&lt;/li&gt;
  &lt;li&gt;탑다운 방식으로 반복합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이를 다음과 같이 구현할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// lv == -1 : leaf node, child with null&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tcnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tcnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lv&lt;/code&gt;은 변경되는 index &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;에서, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 &amp;lt;&amp;lt; lv&lt;/code&gt;을 계산하여 좌우 방향을 결정하기 위해 필요합니다. 연산자 우선 순위에 의해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x &amp;gt;&amp;gt; lv &amp;amp; 1 &lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 &amp;lt;&amp;lt; lv&lt;/code&gt; 자리에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;의 비트가 1인지 묻는 것과 동일합니다. 0이면 왼쪽, 1이면 오른쪽을 갱신합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lv&lt;/code&gt;이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-1&lt;/code&gt;이라는 건 자식이 모두 null pointer (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a[0]&lt;/code&gt;)인, 리프 노드라는 뜻입니다. 기본적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r&lt;/code&gt;이 0으로 초기화되므로, null pointer를 가리키게 됩니다.&lt;/p&gt;

&lt;p&gt;이를 통해 1번 쿼리를 해결할 수 있습니다.&lt;/p&gt;

&lt;p&gt;중요한 점은, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root[i]&lt;/code&gt;는 1번째 수부터 i번째 수까지 추가된 세그트리라는 사실입니다. 밑에서 서술된 쿼리 함수들은 이 성질에 기반해 작동합니다.&lt;/p&gt;

&lt;h2 id=&quot;구간-최대-xor-쿼리&quot;&gt;구간 최대 XOR 쿼리&lt;/h2&gt;

&lt;p&gt;이 문제에서 가장 복잡하면서 흔치 않은 쿼리가 아닌가 생각됩니다. 변화가 점층적으로 이루어진다는 점에 기반하여, i번째부터 j번째 세그먼트 트리를 보고 싶으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root[j]&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root[i-1]&lt;/code&gt;를 비교해가며 따지면 됩니다. prefix sum의 개념과 비슷합니다.&lt;/p&gt;

&lt;p&gt;함수의 로직 자체는 복잡하지 않습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;의 비트를 따져서, XOR를 최대화할 수 있는 방향으로 진행하는 것입니다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pst_xor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pst_xor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pst_xor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pst_xor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pst_xor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;q&lt;/code&gt; 대신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt;를 사용한 이유는 이 두 포인터를 통해 보고자 하는 수들의 범위를 지정할 수 있기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt;는 구간을 처리하기 위한 node 포인터, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;는 2번 쿼리의 값, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lv&lt;/code&gt;는 보아야 할 비트의 위치를 의미합니다. 이 함수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt; 사이에 있는 수 (변화) 중 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;랑 XOR해서 가장 큰 값을 반환합니다.&lt;/p&gt;

&lt;p&gt;이 함수를 통해 2번 쿼리를 해결할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;구간-원소-개수-쿼리&quot;&gt;구간 원소 개수 쿼리&lt;/h2&gt;

&lt;p&gt;j번째 세그트리에서 원소의 개수를 따지는 건 어렵지 않습니다. 역시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;의 비트를 따져가면서 1이면 (왼쪽) + (오른쪽 재귀), 0이면 (왼쪽 재귀)를 더하면 됩니다.&lt;/p&gt;

&lt;p&gt;리프 노드 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lv == -1&lt;/code&gt;)일 때도 값을 더해주는 걸 잊으면 안 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pst_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pst_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pst_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt;는 지금 보고 있는 node 포인터, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;는 4번 쿼리의 값, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lv&lt;/code&gt;는 보아야 할 비트의 위치를 의미합니다. 이 함수는 지금 보고 있는 노드에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 이하의 원소 개수를 반환합니다.&lt;/p&gt;

&lt;p&gt;이 쿼리를 통해 4번 쿼리를 해결할 수 있습니다 (2번 호출하면 됩니다).&lt;/p&gt;

&lt;h2 id=&quot;구간-k번째-원소-쿼리&quot;&gt;구간 k번째 원소 쿼리&lt;/h2&gt;

&lt;p&gt;위에 있던 XOR 쿼리와 비슷하게, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt;를 뺀 게 실제로 우리가 보아야 할 유효한 구간입니다. 답이 되는 index를 포함하는 쪽으로 재귀 함수를 호출합니다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pst_kth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pst_kth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pst_kth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt;는 구간을 처리하기 위한 node 포인터, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k&lt;/code&gt;는 5번 쿼리의 값, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lv&lt;/code&gt;는 보아야 할 비트의 위치를 의미합니다. 이 함수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt; 사이에 있는 수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k&lt;/code&gt;번째로 작은 수를 반환합니다 (1-index).&lt;/p&gt;

&lt;p&gt;이 함수로 5번 쿼리를 해결할 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;main-함수&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 함수&lt;/h1&gt;

&lt;p&gt;나머지 3번 쿼리는&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 함수에서 카운터를 감소하는 걸로 처리할 수 있고, 이제 쿼리만 호출하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ios_base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sync_with_stdio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tie&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tcnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// root node 생성&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pst_xor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pst_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pst_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pst_kth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 짜면, &lt;a href=&quot;https://icpc.me/13538&quot;&gt;BOJ 13538 XOR 쿼리&lt;/a&gt;를 시간 복잡도 $ O(M \lg N)$ 해결할 수 있습니다 ($ N = 2^{19}$).&lt;/p&gt;</content><author><name>Sangheon Lee</name></author><category term="PS" /><category term="Data Structure" /><summary type="html">헷갈리던 Persistent Segment Tree를 드디어 이해했습니다.</summary></entry><entry><title type="html">블로그에 MathJax 추가</title><link href="/blog/add-mathjax/" rel="alternate" type="text/html" title="블로그에 MathJax 추가" /><published>2019-12-29T17:00:00+09:00</published><updated>2019-12-29T17:00:00+09:00</updated><id>/blog/add-mathjax</id><content type="html" xml:base="/blog/add-mathjax/">&lt;p&gt;수식을 보기 좋게 렌더링해주는 &lt;a href=&quot;https://www.mathjax.org/&quot;&gt;MathJax&lt;/a&gt;를 추가하였습니다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;$ e^{\pi i} + 1 = 0$ 같이 인라인 수식도,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;a^2 + b^2 = c^2&lt;/script&gt;

&lt;p&gt;같은 수식도 쓸 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.janmeppe.com/blog/How-to-add-mathjax-to-minimal-mistakes/&quot;&gt;이 포스트&lt;/a&gt;
의 도움을 받아 쉽게 추가할 수 있었습니다.&lt;/p&gt;</content><author><name>Sangheon Lee</name></author><category term="Jekyll" /><summary type="html">수식을 보기 좋게 렌더링해주는 MathJax를 추가하였습니다.</summary></entry><entry><title type="html">Sibelius Violin Concerto in D minor, Op. 47</title><link href="/music/sibelius-violin-concerto/" rel="alternate" type="text/html" title="Sibelius Violin Concerto in D minor, Op. 47" /><published>2019-12-23T01:00:00+09:00</published><updated>2019-12-23T01:00:00+09:00</updated><id>/music/sibelius-violin-concerto</id><content type="html" xml:base="/music/sibelius-violin-concerto/">&lt;p&gt;듣고 왜 이 협주곡을 이전에 알지 못했을까 싶었습니다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;a href=&quot;https://terms.naver.com/entry.nhn?cid=59000&amp;amp;docId=3571046&amp;amp;categoryId=59000&quot;&gt;이 NAVER 지식백과&lt;/a&gt;의 칼럼을 통해
배경과 음악적 느낌을 접하시면 될 것 같습니다.&lt;/p&gt;

&lt;p&gt;연주 시간은 대략 27분에서 33분 정도입니다.&lt;/p&gt;

&lt;!--[![IMAGE ALT TEXT](http://img.youtube.com/vi/YsbrRAgv1b4/0.jpg)](http://www.youtube.com/watch?v=YsbrRAgv1b4 &quot;Video Title&quot;) --&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/YsbrRAgv1b4&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;br /&gt;
연주도 일품이지만, 막심 벤게로프의 표정 변화를 보며 웃음을 참지 못하는 분들도 있으리라 생각합니다.&lt;/p&gt;</content><author><name>Sangheon Lee</name></author><category term="classic" /><summary type="html">듣고 왜 이 협주곡을 이전에 알지 못했을까 싶었습니다.</summary></entry></feed>